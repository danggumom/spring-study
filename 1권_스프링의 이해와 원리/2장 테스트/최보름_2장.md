# 2장. 테스트
## 2.1 UserDaoTest 다시보기
### 2.1.1 테스트의 유용성
테스트란 내가 예상하고 의도했던 대로 코드가 정확하게 동작하는지 확인하는 작업

### 2.1.2 UserDaoTest의 특징

**작은 단위의 테스트**
테스트의 관심이 다르다면 테스트할 대상을 분리하고 집중해서 접근해야 한다.
 
**자동 수행 테스트 코드**

**지속적인 개선과 점진적인 개발을 위한 테스트**
새로운 기능이 기대한 대로 동작되는지 확인할 수 있을 뿐 아니라 기존 기능이 수정한 코드에 영향을 받지 않고 여전히 잘 동작하는지를 확인

### 2.1.3 UserDaoTest의 문제점
**수동 확인 작업의 번거로움**
**실행 작업의 번거로움**
DAO가 증가할 수록 main()메소드도 증가하고 그만큼 번거로워진다.

## 2.2 UserDaoTest 개선
### 2.2.1~2.2.2 테스트 검증의 자동화 ~ 테스트의 효율적인 수행과 결과 관리
**Junit 테스트로 전환**
- public으로 선언할 것
- @Test 어노테이션 붙여줄 것 

**검증 코드 & Junit 테스트 실행**
 `assertThat`이라는 스태틱 메소드를 제공하여 값을 검증할 수 있다.
**AssertJ**

    assertEquals(expected, actual); //Junit
    assertThat(actual).isEqualTo(expected); //AssertJ

## 2.3 개발자를 위한 테스팅 프레임워크 Junit
스프링의 핵심 기능 중 하나인 스프링 테스트 모듈도 JUnit을 이용한다.

### 2.3.2 테스트 결과의 일관성
테스트는 코드에 변경사항이 없다면 항상 동일한 결과를 내야한다. 
**동일한 결과를 보장하는 테스트**

### 2.3.3 포괄적인 테스트
**테스트 메소드는 한 번에 한 가지 검증 목적에만 충실한 것이 좋다**
JUnit은 특정한 테스트 메소드의 실행 순서를 보장해주지 않는다. 테스트의 결과가 테스트 실행 순서에 영향을 받는다면 테스트를 잘 못 만든 것이다. 모든 테스트는 실행 순서에 상관없이 독립적으로 항상 동일한 결과를 낼 수 있도록 해야한다.
**포괄적인 테스트**
네거티브 테스트를 만드는 습관을 들이는 게 좋다.

### 2.3.4 테스트가 이끄는 개발
**기능 설계를 위한 테스트**
만들고 싶은 기능에 대한 조건과 행위, 결과에 대한 내용이 잘 표현되어있어, 마치 잘 작성된 하나의 기능 정의서처럼 보인다.

**테스트 주도 개발(TDD)**
테스트 코드를 먼저 만들고 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법으로, 만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해준다.

테스트를 빼먹지 않고 꼼꼼하게 만들 수 있으며 테스트를 작성하는 시간과 애플리케이션 코드를 작성하는 시간의 간격이 짧아진다.

### 2.3.5 테스트 코드 개선 
**Junit테스트 실행 흐름**
	1. @Test 어노테이션이 붙으면서 public void이며 파라미터가 없는 테스트메서드를 모두 찾는다.
	2. @Before 메소드가 있다면 실행한다.
	3. @Test 메소드를 하나 실행하고 결과를 저장한다.
	4. @After 메소드가 있다면 실행한다.
	5. 나머지 @Test메소드에 대해 2~5를 반복한다.
	6. 모든 테스트의 결과를 종합해서 반환한다.
**@Before** 클래스 내에 존재하는 각각의 @Test를 실행하기 전에 매번 실행돼야하는 메소드를 정의
**@BeforeClass** 모든 테스트를 실행하기 전 딱 한번만 실행돼야하는 메소드를 정의, static으로 선언

**픽스쳐** 테스트를 수행하는데 필요한 정보나 오브젝트
일반적으로 픽스처는 여러 테스트에서 반복적으로 사용되기 때문에 @Before 메소드를 이용해 생성해두면 편리하다.


## 2.4 스프링 테스트 적용
### 2.4.1 테스트를 위한 애플리케이션 컨텍스트 관리
**스프링 테스트 컨텍스트 프레임워크**
**테스트 메소드의 컨텍스트 공유**
**테스트 클래스의 컨텍스트 공유**

- **@ExtendWith(SpringExtension.class)** : Junit 프레임워크의 테스트 실행방법을 확장할 때 사용하는 어노테이션
- **@ContextConfiguration**:자동으로 만들어줄 어플리케이션 컨텍스트의 설정파일 위치를 지정한 것
- **@Autowired**:스프링의 DI에 사용되는 특별한 어노테이션으로, @autowired가 붙은 인스턴스 변수가 있으면 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾아서 타입이 일치하는 빈이 있으면 인스턴스 변수에 주입해준다.
	
### 2.4.2 DI와 테스트
**테스트를 위한 별도의 DI 설정**
**컨테이너 없는 DI 테스트**
**DI를 이용한 테스트 방법 선택**

## 2.5 학습 테스트로 배우는 스프링
### 2.5.1 학습 테스트의 장점
**다양한 조건에 따른 기능을 손쉽게 확인해 볼 수 있다.**
**학습 테스트 코드를 개발중에 참고할 수 있다.**
**프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다.**
**테스트 작성에 좋은 훈련이 된다.**
**새로운 기술을 공부하는 과정이 즐거워진다.**

### 2.5.3 버그 테스트
코드에 오류가 있을 때 그 오류를 가장 잘 드러내 줄 수 있는 테스트
**테스트의 완성도를 높여준다.**
**버그의 내용을 명확하게 분석하게 해준다.**
**기술적인 문제를 해결하는 데 도움이 된다.**
-   테스트는 자동화돼야 하고, 빠르게 실행할 수 있어야 한다.
-   `main()`  테스트 대신 JUnit 프레임워크를 이용한 테스트 작성이 편리하다.
-   테스트 결과는 일관성이 있어야 한다. 코드의 변경 없이 환경이나 테스트 실행 순서에 따라서 결과가 달라지면 안된다.
-   테스트는 포괄적으로 작성해야 한다. 충분한 검증을 하지 않는 테스트는 없는 것보다 나쁠 수있다.
-   코드 작성과 테스트 수행의 간격이 짧을수록 효과적이다.
-   테스트하기 쉬운 코드가 좋은 코드다.
-   테스트를 먼저 만들고 테스트를 성공시키는 코드를 만들어가는 테스트 주도 개발 방법도 유용하다.
-   테스트 코드도 애플리케이션 코드와 마찬가지로 적절한 리팩토링이 필요하다.
-   @Before, @After를 사용해서 테스트 메소드들의 공통 준비 작업과 정리 작업을 처리할 수 있다.
-   스프링 테스트 컨텍스트 프레임워크를 이용하면 테스트 성능을 향상시킬 수 있다.
-   동일한 설정 파일을 사용하는 테스트는 하나의 애플리케이션 컨텍스트를 공유한다.
-   @Autowired를 사용하면 컨텍스트의 빈을 테스트 오브젝트에 DI 할 수 있다.
-   기술의 사용 방법을 익히고 이해를 돕기 위해 학습 테스트를 작성하자.
-   오류가 발견될 경우 그에 대한 버그 테스트를 만들어두면 유용하다.


